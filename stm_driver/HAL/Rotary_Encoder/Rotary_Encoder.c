/*
 * Rotary_Encoder.c
 *
 *  Created on: Jan 28, 2023
 *      Author: hp
 */


#include "Rotary_Encoder.h"


ROTARY_ENCODER_ID ROTARY_ENCODERS[Number_OF_ENCODERS] = {{255}};
u8 Number_of_Used_ROTARY_ENCODERS = 0;

void ROTARY_ENCODER_INIT(
		ROTARY_ENCODER_ID* ROTARY_ENCODER,
		EXTI_LineNumber_ID EXTI_LineNumber_A,EXTI_PIN_TYPE_ID EXTI_PIN_TYPE_A,
		GPIO_ID* ROTARY_ENCODER_GPIO_B,u8 ROTARY_ENCODER_PIN_B,
		GPIO_ID* ROTARY_ENCODER_PUSHBUTTON_GPIO,u8 ROTARY_ENCODER_PUSHBUTTON_PIN,
		u32 TICKS_RATIO_TO_FullCycle
		)


{
	if(Number_of_Used_ROTARY_ENCODERS == Number_OF_ENCODERS)
	{
		ROTARY_ENCODER->ROTARY_ENCODER_Ticket = 250;
		return ;
	}

	ROTARY_ENCODERS[Number_of_Used_ROTARY_ENCODERS].EXTI_LineNumber_A = EXTI_LineNumber_A;
	ROTARY_ENCODERS[Number_of_Used_ROTARY_ENCODERS].EXTI_PIN_TYPE_A = EXTI_PIN_TYPE_A;
	ROTARY_ENCODERS[Number_of_Used_ROTARY_ENCODERS].ROTARY_ENCODER_GPIO_B = ROTARY_ENCODER_GPIO_B;
	ROTARY_ENCODERS[Number_of_Used_ROTARY_ENCODERS].ROTARY_ENCODER_PIN_B = ROTARY_ENCODER_PIN_B;



	ROTARY_ENCODERS[Number_of_Used_ROTARY_ENCODERS].ROTARY_ENCODER_PUSHBUTTON_GPIO = ROTARY_ENCODER_PUSHBUTTON_GPIO;
	ROTARY_ENCODERS[Number_of_Used_ROTARY_ENCODERS].ROTARY_ENCODER_PUSHBUTTON_PIN = ROTARY_ENCODER_PUSHBUTTON_PIN;

	ROTARY_ENCODERS[Number_of_Used_ROTARY_ENCODERS].ROTARY_ENCODER_Ticket = Number_of_Used_ROTARY_ENCODERS;
	ROTARY_ENCODER = ROTARY_ENCODERS+Number_of_Used_ROTARY_ENCODERS;
	Number_of_Used_ROTARY_ENCODERS++;



	GPIO_void_PIN_MODE(ROTARY_ENCODER_GPIO_B, ROTARY_ENCODER_PIN_B, GPIO_INPUT_PULLUP);
	GPIO_void_PIN_MODE(ROTARY_ENCODER_PUSHBUTTON_GPIO, ROTARY_ENCODER_PUSHBUTTON_PIN, GPIO_INPUT_PULLUP);

	switch(EXTI_PIN_TYPE_A)
	{

	case EXTI_PA:
		GPIO_void_PIN_MODE(GPIOA_REGS, EXTI_LineNumber_A, GPIO_INPUT_PULLUP);
		ROTARY_ENCODER->ROTARY_ENCODER_GPIO_A = GPIOA_REGS;
		break;

	case EXTI_PB:
		GPIO_void_PIN_MODE(GPIOB_REGS, EXTI_LineNumber_A, GPIO_INPUT_PULLUP);
		ROTARY_ENCODER->ROTARY_ENCODER_GPIO_A = GPIOB_REGS;
		break;

	case EXTI_PC:
		GPIO_void_PIN_MODE(GPIOC_REGS, EXTI_LineNumber_A, GPIO_INPUT_PULLUP);
		ROTARY_ENCODER->ROTARY_ENCODER_GPIO_A = GPIOC_REGS;
		break;


	case EXTI_PD:
		GPIO_void_PIN_MODE(GPIOD_REGS, EXTI_LineNumber_A, GPIO_INPUT_PULLUP);
		ROTARY_ENCODER->ROTARY_ENCODER_GPIO_A = GPIOD_REGS;
		break;

	case EXTI_PE:
		GPIO_void_PIN_MODE(GPIOE_REGS, EXTI_LineNumber_A, GPIO_INPUT_PULLUP);
		ROTARY_ENCODER->ROTARY_ENCODER_GPIO_A = GPIOE_REGS;
		break;
	case EXTI_PH:
		GPIO_void_PIN_MODE(GPIOH_REGS, EXTI_LineNumber_A, GPIO_INPUT_PULLUP);
		ROTARY_ENCODER->ROTARY_ENCODER_GPIO_A = GPIOH_REGS;
		break;

	}

	EXTI_void_ENABLE_INT(EXTI_LineNumber_A, EXTI_PIN_TYPE_A, EXTI_Rising, ROTARY_ENCODER_ISR);

}


/* the start position is 0
 * if the signal is inverted increment if the same subtract
*/
u16 ROTARY_ENCODER_u16_GET_ANGLE(ROTARY_ENCODER_ID* ROTARY_ENCODER)
{

	return abs(((ROTARY_ENCODER->increment_Value%ROTARY_ENCODER->TICKS_RATIO_TO_FullCycle) /
			ROTARY_ENCODER->TICKS_RATIO_TO_FullCycle)*360);

}

u8 ROTARY_ENCODER_u8_GET_INPUT(ROTARY_ENCODER_ID* ROTARY_ENCODER)
{

	return GPIO_u8_PIN_READ(ROTARY_ENCODER->ROTARY_ENCODER_PUSHBUTTON_GPIO,ROTARY_ENCODER->ROTARY_ENCODER_PUSHBUTTON_PIN);
}

void ROTARY_ENCODER_ISR(void)
{

	for(u8 i = 0;i<Number_OF_ENCODERS;i++)
	{

		if(ROTARY_ENCODERS[i].ROTARY_ENCODER_Ticket != 255)
		{
			if(EXTI_u8_GetPending_LINE_INT(ROTARY_ENCODERS[i].EXTI_LineNumber_A))
			{
				if(GPIO_u8_PIN_READ(ROTARY_ENCODERS[i].ROTARY_ENCODER_GPIO_B,ROTARY_ENCODERS[i].ROTARY_ENCODER_PIN_B))
				{
					ROTARY_ENCODERS[i].increment_Value++;
				}
				else
				{
					ROTARY_ENCODERS[i].increment_Value--;
				}

			}

		}

	}



}

